# LeetCode
## 001 . 两数之和
方法1：先排序，然后选出和为目标值的数字，再返回原数组查找
<br/>
方法2：使用哈希表，然后遍历数组，看是否存在 target - left 的值
## 002 . 两数相加
先创建一个空节点，指向真正的用来指向真正的头结点，并用来保证代码的一致性。
<br/>
通过一个临时值记录下一位是否进1，以保证下一位不会被遗漏。
## 003 . 无重复字符的最长子串
通过 int 数组充当 hash 表，以判断前面出现的同样的字符的下标
## 004 . 寻找两个正序数组的中位数
方法1：合并两个数组遍历，找到下标为 (m + n) / 2 和 (m + n) / 2 + 1 的值。O(m + n)
方法2：动态二分查找，由于两个数组都已排序，所以其中的数都在中位数两侧，因此在两个数组可分别找到一个位置，该位置左边与右边的元素个数相同或相差 1，同时在两个数组该位置左侧的元素都比右边的元素要小，找出该位置即可。O(log(m + n))
## 005 . 最长回文子串
方法1：中心扩展法。以中心向两端进行比较。时间 O(n^2)，空间 O(1)
<br/>
方法2：Manacher。中心扩展的同时，根据现中心给右侧的元素赋予回文长度。当右侧回文长度超过当前回文串的长度时，以该元素为中心进行回文检查。
## 006 . Z 字形变换
找规律
## 007 . 整数反转
注意可能会导致超出有效范围的情况。与 MAX_INT/10 和 MIN_INT/10 作对比。以及当已经转移的位数为 30 且当前值等于  MAX_INT/10 或 MIN_INT/10 时，最后一位与 7 进行对比。
## 008 . ATOI
各种特殊情况。先除去前面的空格，然后判断是否存在符号，然后判断前面是否为 0
## 009 . 回文数
用一个数组存储各个位的数字，然后两边进行对比
## 010 . 正则表达式匹配
动态规划。构建 n*m 的数组，其中 dp[i][j] 表示正则表达式 regular 前 i 个字符能否与前 j 个待匹配字符串 target 匹配，最后查看 dp[n][m] 的结果即可。时间 O(n*m)，空间 O(n*m)。
<br/>
dp[0][0] 表示 0 个正则表达式与 0 个目标字符串匹配为 true。
<br/>
当 regular[j] 为 * 时，dp[i][j] 为 dp[i][j-2] 与 target[i] == regular[j - 1] 或 regular[j - 1] == '.' 时， regular[i][j] 为 true。
<br/>
最后 dp[n][m] 即为结果。
## 011 . 盛最多水的容器
双指针法。在两侧同时往中间靠拢，当前的盛水量等于较低的边乘以宽度，随后较短的一侧往中间靠拢以查找是否有更大的值。
## 012 . 整数转罗马数字
通过键值表反向排序，同时插入特殊的如4、9等键值，然后依次相减直至获得最终结果。O(logn)，n为数字位数。
## 013 . 罗马数字转整数
通过键值表反向排序，同时插入特殊的如4、9等键值，然后依次相减直至获得最终结果。O(logn)，n为数字位数。
## 014 . 最长公共前缀
字符串同一位进行匹配即可。
## 015 . 三数之和
先对原数组进行排序，然后通过双指针法找到结果。通过排除重复元素减少重复计算。时间 O(n^2)，空间 O(logn)。
## 016 . 最接近的三数之和
先对原数组进行排序，然后通过双指针法找到结果。每次用当前三个数的和与目标值的差值的绝对值，与之前获得的差值进行比较，较小则替换。时间 O(n^2)。
## 017 . 电话号码的字母组合
创建字典，然后使用数组存储上一次遍历的值，下一次遍历时遍历该数组然后进行字符串的组合即可。时间 O(3^n),空间 O(3^n)。
## 018 . 四数之和
类似于之前三数之和做法，时间 O(n^3)，空间 O(logn)。
## 019 . 删除链表的倒数第 N 个结点
双指针法，一个指针移动了 N 次后，第二个指针才开始移动。时间 O(n)，空间 O(1)。
同时，使用一个前置节点，以头结点作为该前置节点的下一个节点，返回结果时直接返回前置节点的子结点以减少特殊条件的判断。
## 020 . 有效的括号
使用栈，当左括号时入栈，右括号时出栈然后判断是否是对应的括号。
通过一个数组作为 HashMap，通过该数组判断括号是否匹配。


