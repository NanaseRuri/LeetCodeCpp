# LeetCode

## 001 . 两数之和

&emsp; &emsp; 方法1：先排序，然后选出和为目标值的数字，再返回原数组查找<br/>
&emsp; &emsp; 方法2：使用哈希表，然后遍历数组，看是否存在 target - left 的值

## 002 . 两数相加

&emsp; &emsp; 先创建一个空节点，指向真正的用来指向真正的头结点，并用来保证代码的一致性。<br/>
&emsp; &emsp; 通过一个临时值记录下一位是否进1，以保证下一位不会被遗漏。

## 003 . 无重复字符的最长子串

&emsp; &emsp; 通过 int 数组充当 hash 表，以判断前面出现的同样的字符的下标

## 004 . 寻找两个正序数组的中位数

&emsp; &emsp; 方法1：合并两个数组遍历，找到下标为 (m + n) / 2 和 (m + n) / 2 + 1 的值。<br>
&emsp; &emsp; 时间复杂度 O(m + n)，空间复杂度 O(m + n)<br/>
&emsp; &emsp; 方法2：动态二分查找，由于两个数组都已排序，所以其中的数都在中位数两侧，因此在两个数组可分别找到一个位置，该位置左边与右边的元素个数相同或相差 1，同时在两个数组该位置左侧的元素都比右边的元素要小，找出该位置即可。<br/>
&emsp; &emsp; 时间复杂度 O(log(m + n))，空间复杂度 O(1)。

## 005 . 最长回文子串

&emsp; &emsp; 方法1：中心扩展法。以中心向两端进行比较。<br/>
&emsp; &emsp; 时间复杂度 O(n^2)，空间复杂度 O(1)<br/>
&emsp; &emsp; 方法2：Manacher。中心扩展的同时，根据现中心给右侧的元素赋予回文长度。当右侧回文长度超过当前回文串的长度时，以该元素为中心进行回文检查。

## 006 . Z 字形变换

&emsp; &emsp; 找规律

## 007 . 整数反转

&emsp; &emsp; 注意可能会导致超出有效范围的情况。与 MAX_INT/10 和 MIN_INT/10 作对比。以及当已经转移的位数为 30 且当前值等于  MAX_INT/10 或 MIN_INT/10 时，最后一位与 7 进行对比。

## 008 . ATOI

&emsp; &emsp; 各种特殊情况。先除去前面的空格，然后判断是否存在符号，然后判断前面是否为 0

## 009 . 回文数

&emsp; &emsp; 用一个数组存储各个位的数字，然后两边进行对比

## 010 . 正则表达式匹配

&emsp; &emsp; 动态规划。构建 n * m 的数组，其中 dp[i][j] 表示正则表达式 regular 前 i 个字符能否与前 j 个待匹配字符串 target 匹配。<br/>
&emsp; &emsp; dp[0][0] 表示 0 个正则表达式与 0 个目标字符串匹配为 true。<br/>
&emsp; &emsp; 当 regular[j] 为 * 时，dp[i][j] 为 dp[i][j-2] 与 target[i] == regular[j - 1] 或 regular[j - 1] == '.' 时， regular[i][j] 为 true。<br/>
&emsp; &emsp; 最后 dp[n][m] 即为结果。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度 O(n * m)。

## 011 . 盛最多水的容器

&emsp; &emsp; 双指针法。在两侧同时往中间靠拢，当前的盛水量等于较低的边乘以宽度，随后较短的一侧往中间靠拢以查找是否有更大的值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 012 . 整数转罗马数字

&emsp; &emsp; 通过键值表反向排序，同时插入特殊的如4、9等键值，然后依次相减直至获得最终结果。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。n为数字位数。

## 013 . 罗马数字转整数

&emsp; &emsp; 通过键值表反向排序，同时插入特殊的如4、9等键值，然后依次相减直至获得最终结果。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。n为数字位数。

## 014 . 最长公共前缀

&emsp; &emsp; 字符串同一位进行匹配即可。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 015 . 三数之和

&emsp; &emsp; 先对原数组进行排序，然后通过双指针法找到结果。通过排除重复元素减少重复计算。<br/>
&emsp; &emsp; 由于需要记录不重复的组个数，时间复杂度 O(n^2)，空间复杂度 O(logn)。

## 016 . 最接近的三数之和

&emsp; &emsp; 先对原数组进行排序，然后通过双指针法找到结果。每次用当前三个数的和与目标值的差值的绝对值，与之前获得的差值进行比较，较小则替换。<br/>
&emsp; &emsp; 时间复杂度 O(n^2)，空间复杂度 O(1)。

## 017 . 电话号码的字母组合

&emsp; &emsp; 创建字典，然后使用数组存储上一次遍历的值，下一次遍历时遍历该数组然后进行字符串的组合即可。<br/>
&emsp; &emsp; 时间复杂度 O(3^n), 空间复杂度 O(3^n)。

## 018 . 四数之和

&emsp; &emsp; 类似于之前三数之和做法。<br/>
&emsp; &emsp; 时间复杂度 O(n^3)，空间复杂度 O(logn)。

## 019 . 删除链表的倒数第 N 个结点

&emsp; &emsp; 双指针法，一个指针移动了 N 次后，第二个指针才开始移动。<br/>
&emsp; &emsp; 同时，使用一个前置节点，以头结点作为该前置节点的下一个节点，返回结果时直接返回前置节点的子结点以减少特殊条件的判断。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。<br/>

## 020 . 有效的括号

&emsp; &emsp; 使用栈，当左括号时入栈，右括号时出栈然后判断是否是对应的括号。<br/>
&emsp; &emsp; 通过一个数组作为 HashMap，通过该数组判断括号是否匹配。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 021 . 合并两个有序链表

&emsp; &emsp; 使用一个前置节点，以头结点作为该前置节点的下一个节点，返回结果时直接返回前置节点的子结点以减少特殊条件的判断。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 022 . 括号生成

&emsp; &emsp; 迭代，用左括号以及右括号剩余个数作为参数，当两个个数一致时将生成的字符串放入结果中。<br/>
&emsp; &emsp; 该问题可视为入栈出栈问题，时间复杂度为卡特兰数通项 O(4^n/n^(1/2))，空间复杂度为递归深度 O(n)。

## 023 . 合并K个升序链表

&emsp; &emsp; 先构造一个小堆顶，堆的长度为非空链表个数 + 1, 加 1 为了添加一个零号节点，用于方便后续调整的判断。将每个链表的首元素放进去，初始化堆之后，每次取堆的下标为 1 的元素。如果该元素存在下一个节点，则将该下标的元素赋值为该下一个节点，同时对堆进行调整。若不存在下一个节点，则堆的长度 -1，同时将最后一个元素赋值给第一个元素，然后进行调整，直到堆的长度为 1，即零号节点则全部元素获取完毕。<br/>
&emsp; &emsp; 时间复杂度 O(nlog(m))，空间复杂度为 O(m)。n 为所有链表总元素个数，m 为链表数组的链表元素个数。

## 024 . 两两交换链表中的节点

&emsp; &emsp; 日常用一个空置节点减少判断。然后分别记录下交换后的后一个节点以作为下一次节点交换的前节点。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 025 . K 个一组翻转链表

&emsp; &emsp; 日常用一个空置节点减少判断。然后可以转过来想，相当于把后面的节点都插入到第一个节点，然后将该节点的首位置进行重置，只需要声明两个指针即可完成工作。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 026 . 删除有序数组中的重复项

&emsp; &emsp; 设置两个指针 left, right，初始值都为 1，当 nums[right - 1] == nums[right] 时，将 nums[left] 赋值为 nums[right] 同时 left++。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 027 . 移除元素

&emsp; &emsp; 双指针，然后左指针相等时，将其与右指针的值交换，同时右指针不能为相同的元素值，并且记录相同元素个数，然后返回数组长度减去相同元素个数。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 028 . 实现 strStr

&emsp; &emsp; KMP，先构造 KMP 数组，该数组记录了每次重新匹配开始的位置，避免了暴力搜索的多余的匹配。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(m)，n 为源字符串 haystack 的长度，m 为目标字符串 needle 的长度。

## 029 . 两数相除

&emsp; &emsp; 每次使用移位来进行幂级别的商。由于 LeetCode 上的 C++ 编译器不支持负数的位运算以及对 INT32_MIN 的取负操作，所以使用 unsigned int 并且使用位运算将负数转换为 unsigned 的正数，并在返回时再进行一次位运算返回负数。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。n 为 dividend/divisor。

## 030 . 串联所有单词的子串

&emsp; &emsp; 建立哈希表，分别记录每个单词需要出现的次数，每个单词已经出现的下标，每次出现单词的下标与对应的单词。当上一轮循环没有找到到此且这轮循环找到单词时，直接插入哈希表。如果上一轮循环找到，这轮找到，且出现次数未超出限制，则直接插入，否则需要去除该单词第一次出现的下标前的信息。<br/>
&emsp; &emsp; 循环 K 次滑动窗口，K为单词的长度，由于单词长度一致，所以窗口每次循环移动为 K。一轮窗口循环后下标 +1 再执行循环，直至 K 次循环完成。<br/>
&emsp; &emsp; 时间复杂度 O(Kn)，n 为字符串 s 的长度。空间复杂度 O(m)，m 为字符串组 words 的字符串个数。

## 031 . 下一个排列

&emsp; &emsp; 题目要求原地修改，空间复杂度 O(1)，只需两轮反向筛选的循环然后对替换过后的位数进行堆排序即可。

## 032 . 最长有效括号

&emsp; &emsp; 方法 1：两轮遍历，从左到右进行遍历，若左括号与右括号数量相同，则更新最长括号数，若右括号个数大于左括号，则括号数置零。同理从右到左遍历。综合两次遍历的结果获得最终的长度。时间复杂度 O(n)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：使用栈，先放入 -1，然后遍历字符串，如果为左括号则入栈，右括号则出栈。出栈时判断若当前栈为空，则放入当前下标作为下一次计算长度的初始值；若不为空则使用当前下标减去栈顶的值作为当前获取的有效括号长度。时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 3：动态规划，若当前为右括号，则判断是否 i - dp[i-1] - 1 >= 0，若为真，则判断 i - dp[i-1] - 1 在字符串中是否为左括号，若为左括号，当前的值为 2 + dp[i-1]，且判断左括号前一个下标 i - dp[i-1] - 1 - 1 >= 0，若为真，则当前的值为 2 + dp[i-1] + dp[dp[i-1] - 1 - 1]，最后遍历动态规划数组找到最大长度。时间复杂度 O(n)，空间复杂度 O(n)。

## 033 . 搜索旋转排序数组

&emsp; &emsp; 变种二分查找，先找到旋转中心，然后根据下标为 0 的值和旋转中心的值做对比决定二分查找的区域。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 034 . 在排序数组中查找元素的第一个和最后一个位置

&emsp; &emsp; 变种二分查找，先找到等于目标值的下标，然后在该下标左右再分别进行二分查找，找到 nums[n] == target && nums[n - 1] != target 以及 nums[m] == target && nums[m + 1] != target 的位置。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 035 .  搜索插入位置

&emsp; &emsp; 变种二分查找，先找到等于目标值的下标，若找不到则返回 left 即为插入值。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 036 . 有效的数独

&emsp; &emsp; 遍历数组，依次判断横竖以及实线内是否有重复元素即可。<br/>
&emsp; &emsp; 因为 n 为固定值，时间复杂度 O(1)，空间复杂度 O(1)。

## 037 . 解数独

&emsp; &emsp; 递归，深度优先遍历。<br/>
&emsp; &emsp; 先统计各行各列以及各个九宫格中已有的数字，同时当不存在数字时，将其位置放入一个列表中，以减少后续的遍历。然后对该位置列表进行遍历，并进行 dfs，递归条件为遍历 1-9，当其不在行、列及九宫格中时，将其在各行、各列以及九宫格中赋值，进行下一层 dfs，然后在 dfs 结束时，根据标志位判断是否已赋值元素个数是否等于待赋值元素个数，若相等，则将数独中的元素赋值，各层 dfs 结束。否则则将其在各行、各列以及九宫格中的值重置。<br/>
&emsp; &emsp; 时间复杂度 O(n^9)，空间复杂度 O(n)，n 为数独中的空白元素个数。

## 038 . 外观数列

&emsp; &emsp; 理解题意后进行递归即可<br/>
&emsp; &emsp; 由于需要进行 n 次递归，同时每次迭代使用的都是先前的结果。时间复杂度 O(n)，空间复杂度 O(1)。

## 039 . 组合总和

&emsp; &emsp; 递归。递归的函数参数分别为原数组的引用 candidates，当前已组合元素数组的引用 currentResult (用来避免值传递的内存以及时间消耗)，当前遍历开始的下标 startIndex，当前已组合元素数组的总值 currentSum，以及目标值 target。<br/>
&emsp; &emsp; 当总和等于目标值时，拷贝 currentResult 放入总结果中，移除 currentResult 的最后一个元素，直接返回。<br/>
&emsp; &emsp; 从 startIndex 开始遍历 candidates，如果 candidates[i] + currentSum <= target，则进行下一次迭代。否则，移除 currentResult 的最后一个元素然后返回。<br/>
&emsp; &emsp; 若遍历完 candidates 数组没有返回，即没有出现 candidates[i] + currentSum > target 的情况，则需要移除 currentResult 的最后一个元素供上一层的下次迭代使用。<br/>
&emsp; &emsp; 由于每个元素可以被使用的次数未知，最差要进行 n * 2^n 次方的递归，时间复杂度 O(n * 2 ^ n)，空间复杂度 O(n)。

## 040 . 组合总和

&emsp; &emsp; 与 39 题思路一致，但要排除重复元素且每个元素只能使用一次，因此下轮迭代的遍历的下标要从 + 1 开始，且需要通过与 15 题类似的思路排除重复元素即可。<br/>
&emsp; &emsp; 时间复杂度 O(n^n)，空间复杂度 O(n)。

## 041 . 缺失的第一个正数

&emsp; &emsp; 每次将 nums[i] 与 nums[nums[i]-1] 的元素进行交换，确保每个合法数字位于其下标上。然后遍历数组，下标为 i 的元素不等于 i + 1，则返回 i + 1 即为结果。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 042 . 接雨水

&emsp; &emsp; 方法 1：观察图像可知，每个接水的面积都经历一个 height 值变小后变大的过程，使用栈，每次高度下降时将高度差以及下标入栈，每次高度上升时，高度差若小于栈顶高度，则记录上升高度到起始位置之间的面积，同时栈顶高度需要减去当前高度。若大于等于栈顶高度，则计算完面积后出栈。计算到最后获得最终结果。<br/>
&emsp; &emsp; 方法 1 时间复杂度 O(n)，空间复杂度 O(m)，n 为 height 的元素个数，m 为柱子的最高高度。<br/>
&emsp; &emsp; 方法 2：使用双指针法，确保每根能接水的柱子的左侧柱子的最高高度小于右侧柱子的最高高度，然后对该柱子的高度进行相加得到最终结果。<br/>
&emsp; &emsp; 方法 2 时间复杂度 O(n)，空间复杂度 O(1)。

## 043 . 字符串相乘

&emsp; &emsp; 根据分析可知，两个数字相乘会有 num1Size + num2Size - 1 个对应位数相乘的结果，但保留两个数组第一位相乘时可能导致的进位，因此使用长度 num1Size + num2Size 的数组保存位数相乘的结果，位数相乘结果放在 i + j +1 的位置。然后对该存放结果的数组进行处理即可得到最后的结果。但需要注意对前几位为 0 的情况需要进行特殊处理，跳过所有为 0 的位数，若最终跳过的位数等于结果数组长度则返回 0，否则从该位数开始遍历得到结果。<br/>
&emsp; &emsp; 时间复杂度 O(n * m), 空间复杂度 O(n + m)。

## 044 . 通配符匹配

&emsp; &emsp; 方法 1：类似于第 10 题，使用动态规划即可。<br/>
&emsp; &emsp; 当遍历到通配符 * 时，当前的值相当于前一个正则长度值是否匹配、前一个正则长度以及前一个字符串是否匹配，以及前一个字符串与当前正则长度是否匹配的或集。<br/>
&emsp; &emsp; 否则则判断前一个字符串长度和正则长度是否匹配，且当前是否为 ? 或字符是否相等即可。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度 O(n * m)。<br/>
&emsp; &emsp; 方法 2：贪心算法<br/>
&emsp; &emsp; 每次匹配到 * 时，记录下当前位置 sRecord 和 pRecord，如果接下来的字符串匹配失败，判断是否可以回溯之前位置，不可以则匹配失败。可以则 ++sRecord 并将 sRecord 的值赋给 sLeft 继续下一次遍历。遍历到最后，判断 pLeft 与 pRight 之间是否全是 * 号，不是则返回 false。 <br/>
&emsp; &emsp; 最差时间复杂度 O(n * m)，空间复杂度 O(1)。但当字符串 s 和 p 随机时，即 p 不会出现大量间断 * 号时，可以很快的结束遍历，平均起来时间复杂度远小于 O(n * m)。

## 045 . 跳跃游戏 II

&emsp; &emsp; 经典贪心算法题目。<br/>
&emsp; &emsp; 方法 1：从后往前遍历，使用栈存放能跳到该位置的下标，若栈的数目在遍历时发生过变化，出栈，跳跃数 +1；否则则出栈，同时跳跃数 -1，直到找到 0 下标即可。<br>
&emsp; &emsp; 由于每次需要从后往前遍历，同时存在回溯的可能性，时间复杂度 O(n^2)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：从前往后遍历，找到一个能跳到最远位置的格子作为下一次跳跃的下标。<br/>
&emsp; &emsp; 由于题目保证了一定能跳到最后的格子，所以能跳到最远位置的格子一定是最优的格子。因此减少了需要作为回溯的遍历的次数，时间复杂度 O(n)，空间复杂度 O(1)。

## 046 . 全排列

&emsp; &emsp; 类似于第 39 题，使用回溯以及递归的做法。<br/>
&emsp; &emsp; 时间复杂度 O(n * n!)，空间复杂度为递归深度以及存放当前结果个数 n 总和为 O(n)。

## 047 . 全排列 II

&emsp; &emsp; 46 题进阶版，使用回溯以及递归的做法。<br/>
&emsp; &emsp; 方法 1：同时每一层递归需要使用哈希表记录当前层已经找过的数字，如果有重复则进行下一次遍历。<br/>
&emsp; &emsp; 时间复杂度 O(n * n!)，空间复杂度为递归深度以及存放结果个数 n 以及各层需要存放当前层已经遍历过的数字，最差情况为 1 + 2 + ··· + n，总和为 O(n^2)。<br/>
&emsp; &emsp; 方法 2：在递归条件前更改判断条件，确保每一层使用重复数字时是从左到右使用。<br/>
&emsp; &emsp; 时间复杂度 O(n * n!)，空间复杂度为递归深度以及存放结果个数 n，总和为 O(n)。<br/>

## 048 . 旋转图像

&emsp; &emsp; 找到第 i 行，第 i 列，第 length - 1 - i 行，第 length - 1 - i 列的元素的对应关系即可。原地交换元素。<br/>
&emsp; &emsp; 时间复杂度 O(n^2)，空间复杂度 O(1)。n 为行数。

## 049 . 字母异位词分组

&emsp; &emsp; 建立字符串映射到下标的哈希表，遍历字符串，同时用一个临时字符串记录当前字符串，然后对临时字符串进行排序，然后查看是否存在在哈希表中即可。<br/>
&emsp; &emsp; 时间复杂度 O(n^m)，空间复杂度 O(n^m)。n 为字符串个数，m 为字符串的字母数。

## 050 . Pow(x, n)

&emsp; &emsp; 类似于 29 题两数相除的做法。基于 x 不断乘以 2 直到其比 n 要大，然后再用 n 减去以乘以的数字。如果是负号则用 1 除以其正数幂即可。同时由于不像 29 题存在不准使用大数的限制，使用大数强制转换 n 以方便处理。同时需要对 x 的幂可能出现无穷小以及无穷大的情况进行处理。<br/>
&emsp; &emsp; 官方做法：对 n 不断 %2 进行判断，若等于 1，则用结果乘以当前幂，否则当前幂乘以当前幂，且 n/=2。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。n 为参数 n 的大小。

## 051 . N 皇后

&emsp; &emsp; 类似于 37 题解数独的做法进行递归即可。同时由于棋盘的对称性，只需要遍历一半的棋盘格，然后进行对称计算得到另一半即可。<br/>
&emsp; &emsp; 由于需要遍历 n! 次，然后每个元素赋值后需要给纵向、下方斜向的元素标志，每个元素需要执行 (2 * (n - 1) + (n - 2)…… + 1) / n = O(n) 次，因此时间复杂度为 O(n! * n)，然后记录每个皇后下方以及斜下方状态的数组，空间复杂度为 O(n ^ 2)。<br/>
&emsp; &emsp; 官方做法，使用哈希表然后通过下标判断之前某个是否有皇后，时间复杂度为 O(n!)，空间复杂度为 O(n)。

## 052 . N 皇后 II

&emsp; &emsp; 第 51 题的简化版，省去了记录结果的步骤。但仍需要记录每个皇后下方以及斜下方的状态。<br/>
&emsp; &emsp; 时间复杂度 O(n!)，空间复杂度 O(n ^ 2)。

## 053 . 最大子序和

&emsp; &emsp; 经典贪心题。相加至当前值小于零时，将当前总和置零即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 054 . 螺旋矩阵

&emsp; &emsp; 通过观察可知前 row / 2 + row % 2 的行为顺序遍历，后 row / 2 的行为反向遍历，右 col / 2 + col % 2 列的为顺序遍历，左 col / 2 的列为反向遍历。同时约定每一圈的顺序遍历的个数比反向遍历的个数多一个，然后当行遍历完判断是否为 row / 2 行，从上往下遍历列时判断是否为 col / 2 列，从下往上遍历列时，判断是否 col / 2 - 1 列，是则结束遍历。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 055. 跳跃游戏

&emsp; &emsp; 经典贪心题目，参照 45 题做法。只需遍历 size - 2 项，当 i 等于上次的最远位置且最远位置没有被更新时，返回 false，否则返回 true。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 056 . 合并区间

&emsp; &emsp; 先对区间以每个区间的首元素进行排序，然后遍历区间，将第一个区间插入结果，当后一个区间的首元素比结果的最后一个区间的首元素大时，更新最后一个区间的右区间，直到遍历完结果。<br/>
&emsp; &emsp; 时间复杂度遍历依次数组以及做一次排序的耗时 O(n) + O(nlogn) = O(nlogn)，空间复杂度 O(1)。

## 057 . 插入区间

&emsp; &emsp; 56 题变种，由于题目保证了原区间有序且不重叠，只需要在原区间中二分查找找到插入位置，然后在原数组以插入位置为起始点分别向后遍历看是否需要合并区间，最后不需要合并区间的地方依次加入结果数组即可。<br/>
&emsp; &emsp; 时间复杂度 O(logn) + O(n) = O(n)，空间复杂度 O(1)。

## 058 . 最后一个单词的长度

&emsp; &emsp; 送分题。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 059 . 螺旋矩阵 II

&emsp; &emsp; 54 题变种，初始化数组然后根据 54 的遍历方式给数组赋值即可。<br/>
&emsp; &emsp; 同时由于是 n * n 的矩阵且最后的值为 n ^ 2，因此只需要在横向的时候判断当前已赋过的值是否等于 n ^ 2 即可退出循环。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 2)，空间复杂度 O(1)。

## 060 . 排列序列

&emsp; &emsp; 方法 1 ： 不带脑子，46 题的变种，通过一个全局变量记录当前为第几个，以及利用一个标志位判断之前的递归是否已得到结果，已得到则不再遍历即可。<br/>
&emsp; &emsp; 时间复杂度 O(m)，空间复杂度为存放各个位使用情况的状态数组以及存放当前结果的结果数组总的数组空间 O(n) 以及递归深度 O(n) = O(n)。<br/>
&emsp; &emsp; 方法 2 ： 带脑子，根据数学性质，分别将 k 对 (n - 1)!、(n - 2)!、(n - 3)!... 1 进行相除，获得商作为当前数组的下标，然后余数用于下一轮相除，得到最后即为结果。 <br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为存放集合数组的长度 O(n)。<br/>

## 061 . 旋转链表

&emsp; &emsp; 先遍历一次链表，得到链表长度。如果链表长度小于等于 1 则直接返回 head，然后将 k 对链表长度进行取余，如果 k 的值等于 0 则直接返回 head。然后遍历链表获得链表的倒数第 k 个节点以及倒数第 k + 1 个节点，倒数第 k + 1 个节点 next 置为 nullptr，倒数第 k 个节点 next 置为原本的 head 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 062 . 不同路径

&emsp; &emsp; 方法 1 ： 不带脑子，经典 dp，创建 m * n 长度的 dp 数组，每个元素为其左边元素以及右边元素的和。最后 dp[m - 1][n - 1] 即为所得结果。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，空间复杂度 O(m * n)。<br/>
&emsp; &emsp; 方法 2 ： 带脑子，相当于在 m + n -2 中选取 m - 1 个地方插入下符号或者选取 n - 1 个地方插入右符号，根据排列组合性质可知，这两者结果一致，所以可选取更小的一方以减少阶乘所耗的时间。<br/>
&emsp; &emsp; 时间复杂度 O(min(m, n))，空间复杂度 O(1)。

## 063 . 不同路径 II

&emsp; &emsp; 方法 1 ： 不带脑子，经典 dp，创建 m * n 长度的 dp 数组，每个元素为其左边元素以及右边元素的和。最后 dp[m - 1][n - 1] 即为所得结果。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，使用长度为 n 的滚动数组，在下一次遍历时重新给数组赋值，可以将空间复杂度优化为 O(n)。

## 064 . 最小路径和

&emsp; &emsp; 经典 dp。先遍历第一行给 dp 数组赋初始值。后续行遍历时，dp 的值为先前的值以及上一次轮遍历时的值和前一个元素的最小值。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，使用滚动数组将空间复杂度优化到 O(n)。

## 065 . 有效数字

&emsp; &emsp; 首先先判断第一位是否正负号，是则开始遍历的下标从 1 开始，然后开始遍历。<br/>
&emsp; &emsp; 通过状态位标志是否遍历过数字、是否遍历过小数点，当遍历到小数点时，若先前遍历过小数点，则返回 false。<br/>
&emsp; &emsp; 遍历到 e 时，若之前没有遍历过数字，则返回 false。否则则判断后续是否一个整数，如果后续长度为 0 则返回 false，否则进行整数判断。<br/>
&emsp; &emsp; 如果没有遍历到 e，最后则会返回是否遍历过数字即可。
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 066 . 加一

&emsp; &emsp; 通过标志位判断是否需要对当前位进 1。同时遍历完数组后，如果标志位仍为 true，则需要在 0 插入 1。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 067 . 二进制求和

&emsp; &emsp; 通过标志位判断是否需要对当前位进 1。同时遍历完数组后，如果标志位仍为 true，则需要在 0 插入 1。<br/>
&emsp; &emsp; 在具体实现上，使用临时变量存储长度较短的字符串以及长度较长的字符串，使用反向迭代器，遍历完较短数组后再去遍历较长数组即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 068 . 文本左右对齐

&emsp; &emsp; 写作贪心，实际上为各种丑陋的边界条件处理（bushi）。需要特别注意不是最后一行时，不能刚好用单词填满空位，需要留有空格。总感觉题目哪里有些问题。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 068 . 文本左右对齐

&emsp; &emsp; 写作贪心，实际上为各种丑陋的特殊处理（bushi）。需要特别注意不是最后一行时，不能刚好用单词填满空位，需要留有空格。总感觉题目哪里有些问题。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 069. Sqrt(x)

&emsp; &emsp; 方法 1：通过牛顿迭代法找到最终结果。<br/>
&emsp; &emsp; 迭代结果按对数级收敛，时间复杂度 O(logn)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：官方做法，不允许直接使用指数函数，但将原函数转为关于 e 的幂函数以及对数函数达成目标。 x ^ (1/2) = (e ^ (lnx)) ^ (1 / 2) = e ^ ((1 / 2) * lnx)。同时考虑到浮点数运算的误差，需要判断该结果 +1 时的平方是否小于结果，是则返回 +1 的结果。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 070. 爬楼梯

&emsp; &emsp; 经典 dp，使用滚动数组减少空间复杂度。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 071 . 简化路径

&emsp; &emsp; 各种各样的特殊处理。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 072 . 编辑距离

&emsp; &emsp; 创建一个长宽分别为 word2Size + 1 和 word1Size + 1 的数组，然后对其第 0 行以及第 0 列分别代表着 word1 需要删除几个字符才是空白字符，空白字符需要增加几个字符才能称为 word2。然后 dp[i][j] 则代表 word1 需要进行几步才能转换为 word2。<br/>
&emsp; &emsp; 状态转移公式为：dp[i][j] + (word1[i - 1] == word2[j - 1]) 和 dp[i - 1][j] + 1 和 dp[i][j - 1] + 1 的最小值。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度 O(n * m)。

## 073 . 矩阵置零

&emsp; &emsp; 方法 1：创建一个长度为 row 和 col 的布尔数组，然后遍历矩阵，当当前单元格为 0 时，将当前行和列的布尔数组置为 true。然后遍历两个布尔数组，当为 true 时，分别将对应行和列的单元格值置为 0。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度 O(n + m)。<br/>
&emsp; &emsp; 方法 2：官方常量空间方法。通过两个布尔常量标记首行以及首列是否存在 0，然后利用原数组的第一行和第一列作为方法 1 中记录需要置为 0 的行和列的信息，随后遍历第一行与第一列对各行各列进行赋值即可。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度 O(1)。<br/>

## 074 . 搜索二维矩阵

&emsp; &emsp; 变种二分。<br/>
&emsp; &emsp; 时间复杂度 O(log(n * m))，空间复杂度 O(1)。<br/>

## 075 . 颜色分类

&emsp; &emsp; 由于题意要求排序，否则直接统计数量以时间复杂度 O(n) 空间复杂度 O(1) 的条件完成。<br/>
&emsp; &emsp; 双指针法：通过下标记录 0、1 出现的位置，遍历数组，当出现 0 时将其与 0 的位置交换，如果 0 的位置小于 1 的位置，则说明 0 和 1 的下标之间全为 1，需要交换的则为 1 所在的位置，否则交换 0 的位置。然后 0 和 1 的下标都 +1，如果出现则与 1 进行交换，然后仅仅 1 的下标 +1。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 076 . 最小覆盖子串

&emsp; &emsp; 通过滑动窗口的方法，先每次向右扩展，直到找到一个包含所有字符的子串，然后把左指针向右移，直到不满足条件后，继续向右扩展。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为存储各个字符出现的个数的哈希表 O(m)。

## 077 . 组合

&emsp; &emsp; 46 题全排列的简化版，与 46 题同样采取回溯的方法即可。同时由于是组合数，因此可以排除掉后续一系列没用的递归，只让递归的序号每次从上一个 +1 开始。<br/>
&emsp; &emsp; 时间复杂度 O(C(m, k) * k)，空间复杂度为递归深度以及存储当前递归结果的数组 O(n + k)。C 为组合数公式。<br/>
&emsp; &emsp; 官方做法，根据二进制原理，保证 1 的个数一致，然后依次递增，获取递增后的各个结果。<br/>
&emsp; &emsp; 时间复杂度 O(C(m, k) * k)，空间复杂度为递归深度以及存储当前递归结果的数组 O(k)。C 为组合数公式。

## 078 . 子集

&emsp; &emsp; 77 题变种<br/>
&emsp; &emsp; 时间复杂度 O(C(m, k) * k)，空间复杂度为递归深度以及存储当前递归结果的数组 O(n + k)。C 为组合数公式。<br/>

## 079 . 单词搜索

&emsp; &emsp; 依旧是递归。<br/>
&emsp; &emsp; 因为每次只需要遍历最多 3 条分支，时间复杂度 O(m * n * 3 ^ L)，L 为目标字符串的长度。空间复杂度为存储未被使用的字符的数组 O(m * n)。<br/>

## 080 . 删除有序数组中的重复项 II

&emsp; &emsp; 26 题变种。使用 bool 标志是否重复过即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 081 . 搜索旋转排序数组 II

&emsp; &emsp; 33 题变种。需要判断在 [0, middle] 和 [middle, right] 之间哪个区间为目标的有序区间。而当出现重复数字时，无法知道哪里是有序区间，因此需要将 left 和 right 同时往中间收缩。<br/>
&emsp; &emsp; 时间复杂度 O(log(n))，空间复杂度 O(1)。

## 082 . 删除排序链表中的重复元素 II

&emsp; &emsp; 通过标志位判断是否存在重复元素即可。同时需要注意把最后一个节点的次节点置空。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 083 . 删除排序链表中的重复元素

&emsp; &emsp; 当元素不与之前相同时将当前值加入结果链表即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 084 . 柱状图中最大的矩形

&emsp; &emsp; 暴力法，每个下标进行中心扩展<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 2)，空间复杂度 O(1)，但是会超时。<br/>
&emsp; &emsp; 单调栈法，使用与 42 题类似的思路，栈中存在一个 -1 作为哨兵值。当当前值大于栈中的值时入栈，当小于等于栈中的值时循环出栈，然后将当前元素入栈。当元素出栈时，相当于确定了元素的左右边界，通过计算可得到当前结果，与最大值进行对比即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为栈的深度 O(n)。

## 085 . 最大矩形

&emsp; &emsp; 用临时数组，存储每个元素在行中的连续的 1 的个数，然后遍历每一列。通过与 84 题类似的思路即可。<br/>
&emsp; &emsp; 同时，可以对 0 个 1 的情况进行特殊处理，以减少入栈和出栈的次数。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度为存储临时数组的的空间加上栈的空间 O(n * m + n) = O(n * m)。

## 086 . 分隔链表 

&emsp; &emsp; 需要记录第一个比 x 大的节点，作为每次插入的子节点。记录该节点的前一个节点，以用于作为插入的前一个节点。记录每次遍历到的节点的前一个节点，当遍历到的节点用于放在前面插入时，需要将其后一个节点作为前一个节点的次节点。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 087 . 扰乱字符串

&emsp; &emsp; 动态规划，建立一个 int[sSize][sSize][sSize + 1] 的 dp 数组， dp[i][j][k] 分别代表从字符串 s1、s2 的 i 和 j 下标开始 k 长度是否混淆字符串。最后 dp[0][0][sSize] 即为所得结果。<br/>
&emsp; &emsp; 需考虑是否有进行字符串交换的情况。没有字符串交换的话 dp[i][j][length] 等于从 0 开始遍历到 length 的 dp[i][j][k] && dp[i + k][j + k][length - k]。如果该结果为 true 则直接返回，否则需要判断交换字符串的情形。<br/>
&emsp; &emsp; 当考虑交换字符串的情形时，dp[i][j][length] 等于从 0 开始遍历到 length 的 dp[i + k][j][length - k] && dp[i][j + length - k][k]。<br/>
&emsp; &emsp; dp[i][j][k] 即判断从 i 和 j 开始的 k 个字符数是否相等即可。可先通过判断是否相同的子串以减少递归的次数。<br/>
&emsp; &emsp; 需要对 int[sSize][sSize][sSize + 1] 的元素赋值，同时每个元素需要遍历 sSize 次，时间复杂度 O(n ^ 4)，空间复杂度 O(n ^ 3)。

## 088 . 合并两个有序数组

&emsp; &emsp; 为减少插入元素时交换元素的次数，从后往前遍历然后依次赋给最后的元素。<br/>
&emsp; &emsp; 时间复杂度 O(m)，空间复杂度 O(1)。

## 089 . 格雷编码

&emsp; &emsp; 找规律的题目。从 0 遍历到 n，每次为之前的数字倒序遍历加上 1 左移 i 位。<br/>
&emsp; &emsp; 时间复杂度 O(2 ^ n)，空间复杂度 O(1)。

## 090 . 子集 II

&emsp; &emsp; 47、77 和 78 题的变种。<br/>
&emsp; &emsp; 存在 2 ^ n 的结果，同时每次需要遍历 n 次，时间复杂度 O(n  * 2 ^ n)，空间复杂度为递归深度以及存放临时结果个数 O(n)。

## 091 . 解码方法

&emsp; &emsp; 动态规划，建立一个 int[sSize + 1] 的 dp 数组，遍历字符串，当字符串当前值不为 0 时，当前值加上 dp[i]，然后判断前两个字符串是否小于 26，若小于则加上 dp[i - 1]。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)，但由于状态只与 3 个变量相关，空间复杂度可优化到 O(1)。

## 092 . 反转链表 II

&emsp; &emsp; 相当于从 left 到 right 每次将当前节点插入到头结点。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 093 . 复原 IP 地址

&emsp; &emsp; 使用迭代即可。<br/>
&emsp; &emsp; 每次判断最短长度以及最长长度即减少遍历次数。当有前置 0 时返回。<br/>
&emsp; &emsp; 时间复杂度 O(n * 3 ^ (logn))，空间复杂度为存放当前已匹配 IP 的字符串 O(1)。

## 094 . 二叉树的中序遍历

&emsp; &emsp; 使用栈存放节点，一直遍历左节点然后放入栈，当左节点为空时，出栈，将当前值放入结果。然后遍历循环右节点的左节点即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为栈深度 O(n)。

## 095 . 不同的二叉搜索树 II

&emsp; &emsp; 使用递归。分别递归计算每个节点的左右子树。<br/>

## 096 . 不同的二叉搜索树 II

&emsp; &emsp; 使用递归。分别计算左子树和右子树可能出现的个数然后相乘再相加，则得到当前子树个数。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 2)，空间复杂度 O(n)。可使用动态规划避免递归所带来的的开销。

## 097 . 交错字符串

&emsp; &emsp; 动态规划，数组意义为 s1 的前 i 个字符与 s2 的前 k 个字符是否为交错字符串。<br/>
&emsp; &emsp; 条件为 dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j] || dp[i][j - 1] && s2[j - 1] == s3[i + j -1]。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 2)，空间复杂度 O(n ^ 2)。

## 098 . 验证二叉搜索树

&emsp; &emsp; 对二叉树进行中序遍历，判断后面的值是否比前面的大即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，最坏时全部为同一边的节点，空间复杂度 O(n)。

## 099 . 恢复二叉搜索树

&emsp; &emsp; 方法 1：98 题变种，将 98 题的中序遍历改改即可。<br/>
&emsp; &emsp; 使用栈进行中序遍历，然后遍历数组，查看是否存在后一个元素比前一个元素更小的情况，是则为需要交换的位置。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：使用 Morris 中序遍历去除空间复杂度<br/>
&emsp; &emsp; 核心思想为将左节点的最右节点指向当前节点以除去使用栈存储节点的内存。同时为避免更改树的结构，需要记录先前的右节点并将该右节点的右节点置为 nullptr。<br/>
&emsp; &emsp; 为重置节点，需要遍历两次树，时间复杂度 O(n)，空间复杂度 O(1)。<br/>

## 100 .  相同的树

&emsp; &emsp; 递归即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 101 .  对称二叉树

&emsp; &emsp; 送分题。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 102 .  二叉树的层序遍历

&emsp; &emsp; 送分题。用两个队列即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 103 . 二叉树的锯齿形层序遍历

&emsp; &emsp; 送分题。用两个栈即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 104 . 二叉树的最大深度

&emsp; &emsp; 送分题。深度优先遍历即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 105 . 从前序与中序遍历序列构造二叉树

&emsp; &emsp; 根据分析，前序遍历的首节点为中序遍历中用于区分左右子树的根节点。由此可以得到各个子树的详情，从而还原二叉树。<br/>
&emsp; &emsp; 递归函数的参数分别为前序排序数组、中序排序数组、前序排序数组下标、中序排序排序数组的左边界和右边界，由于区分每一层的左右子树。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 106 . 从中序与后序遍历序列构造二叉树

&emsp; &emsp; 105 题变种，通过分析可知，后序遍历最后一个值为根节点，然后根节点在后续中序遍历的左和右部分的在后序遍历中最后出现的值为下一层的根节点，依次作为递归条件。<br/>
&emsp; &emsp; 递归函数的参数分别为前序排序数组、中序排序数组、前序排序数组下标、中序排序排序数组的左边界和右边界，由于区分每一层的左右子树。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 107 . 二叉树的层序遍历 II

&emsp; &emsp; 102 题变种，使用两个栈一个队列即可，通过队列避免往数组前面插入元素。<br/>
&emsp; &emsp; 同时可以只使用一个栈，然后每次遍历栈前通过栈的深度进行遍历，从而省去一个栈。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 108 . 将有序数组转换为二叉搜索树

&emsp; &emsp; 每次对数组进行二分即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，由于不需要辅助空间，空间复杂度为递归深度 O(logn)。

## 109 . 有序链表转换二叉搜索树

&emsp; &emsp; 方法 1：将链表转换为数组，采用与 108 题一样的方式每次对数组进行二分即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：使用中序遍历的原理，递归函数参数分别为链表头指针的引用，数组范围的左边界和右边界，函数以中序遍历的方式进行实现，而中序的函数则为给当前树的节点值赋值，从而实现二叉树。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(log(n))。

## 110 . 平衡二叉树

&emsp; &emsp; 递归左右子树，并使用标志位 _notBalance 判断先前的判断是否已表示当前子树并非平衡树以进行剪枝，最后当该 _notBalance 为 true 时直接返回 false，否则返回左右子树深度差值是否小于 1。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(H)，H 为树深度。

## 111 . 二叉树的最小深度

&emsp; &emsp; 与 110 类似的做法。深度优先遍历，当左右子树都为空时，使用当前最小深度作为标志位，将当前值与当前最小深度作比较，最后返回最小深度。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(H)，H 为树深度。

## 112 . 路径总和

&emsp; &emsp; 递归，然后每次递归条件为左节点或右节点，然后目标值减去当前根节点的值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(H)，H 为树最大深度。

## 113 . 路径总和 II

&emsp; &emsp; 40 题类似的思路，递归，然后每次递归条件为左节点或右节点，当满足条件时将当前数组加入结果中。不满足则将当前数组的最后一个数字弹出。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 114 . 二叉树展开为链表

&emsp; &emsp; 使用类似 Morris 中序遍历的思想，找到左节点的最右节点，将该最右节点的右节点指向当前的右节点，然后将当前右节点指向该最右节点，并将左节点置为 nullptr 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 115 . 不同的子序列

&emsp; &emsp; 经典 dp，建立一个行和列分别为 sSize + 1 和 tSize + 1 的 dp 数组，dp[i][j] 代表从字符串 s 的 i 下标开始，和字符串 t 从 j 开始，存在几组相同的子序列。<br/>
&emsp; &emsp; 然后循环条件为，当 s[i] == t[j] 时，dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]。否则 dp[i][j] = dp[i + 1][j]。<br/>
&emsp; &emsp; 时间复杂度为 O(n * m)，空间复杂度为 O(n * m)，可优化到 O(m)。

## 116 . 填充每个节点的下一个右侧节点指针

&emsp; &emsp; 方法 1：由于题目允许使用递归，因此在此使用递归，dfs。<br/>
&emsp; &emsp; 递归函数为每次将左节点的 next 指向右节点，然后不断循环左节点的右节点，右节点的左节点重复该步骤直至一者为 nullptr。然后对原来的左节点和右节点分别进行 dfs。<br/>
&emsp; &emsp; 时间复杂度为 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：利用 next 节点进行遍历，从而使空间复杂度变为 O(1)。

## 117 . 填充每个节点的下一个右侧节点指针 II

&emsp; &emsp; 使用一个指针 nextHead 指向当前的下一层节点，然后使用一个备用指针 dump 指向下一层的头结点用于下一次遍历。<br/>
&emsp; &emsp; 遍历 head 的 next 节点，并同步更新 nexthead 的 next 节点，然后将 nextHead 值为 nextHead->next。<br/>
&emsp; &emsp; 时间复杂度为 O(n)，空间复杂度 O(1)。

## 118 . 杨辉三角

&emsp; &emsp; 送分题<br/>
&emsp; &emsp; 时间复杂度为 O(n ^ 2)，空间复杂度 O(1)。

## 119 . 杨辉三角 II

&emsp; &emsp; 送分题<br/>
&emsp; &emsp; 时间复杂度为 O(n ^ 2)，空间复杂度 O(n)。

## 120 . 三角形最小路径和

&emsp; &emsp; 根据分析可知，无论如何都需要遍历完上面的一层，通过两个数组，一个记录当前层，一个记录下一层，然后每次交换两个数组即可。<br/>
&emsp; &emsp; 时间复杂度为 O(n ^ 2)，空间复杂度 O(n)。

## 121 . 买卖股票的最佳时机

&emsp; &emsp; 从前往后遍历，当小于之前的值时，将买入日期设为当前值，否则判断当前卖出价格是否高于最高价格。<br/>
&emsp; &emsp; 时间复杂度为 O(n)，空间复杂度 O(1)。

## 122. 买卖股票的最佳时机 II

&emsp; &emsp; 使用动态规划，使用两个变量记录收益和成本，然后收益为为当前最高收益以及当天价格减去成本的最大值，然后成本为当前成本以及收益减去当前买入价的最大值。<br/>
&emsp; &emsp; 时间复杂度为 O(n)，空间复杂度 O(1)。

## 123. 买卖股票的最佳时机 III

&emsp; &emsp; 使用动态规划，使用四个变量分别记录第一次的成本，第一次的收益，第二次的成本，第二次的收益，使用与 122 题类似的条件进行 dp 即可。<br/>
&emsp; &emsp; 时间复杂度为 O(n)，空间复杂度 O(1)。

## 124 . 二叉树中的最大路径和

&emsp; &emsp; 递归，使用一个字段记录当前节点的最大路径值。每次遍历左路径和右路径的最大值，当前节点的最大路径值为当前节点的值加上左路径与右路径的最大值。<br/>
&emsp; &emsp; 每个节点访问次数不会超过两次，时间复杂度为 O(n)，空间复杂度 O(n)。

## 125 . 验证回文串

&emsp; &emsp; 双指针法，判断是否为数字或字母，不是则往中间收缩。然后判断是否为字母，并判断是否为一个小写字母。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 126 . 单词接龙 II

&emsp; &emsp; 使用图的思想，BFS，将各个单词连通起来。每次判断单词改了一个字母后是否在原列表存在，若存在则将其加入图中。直至加入 endWord 至图中。<br/>
&emsp; &emsp; 时间复杂度 O(n * C ^ 2)，空间复杂度为 O(n * C ^ 2)。C 为单词的长度。

## 127 . 单词接龙

&emsp; &emsp; 126 题简易版。采用与 126 题类似的方法即可。但省去了把图连通的步骤。<br/>
&emsp; &emsp; 时间复杂度 O(n * C ^ 2)，空间复杂度为 O(n * C ^ 2)。C 为单词的长度。

## 128 . 最长连续序列

&emsp; &emsp; 使用 unorder_set 存放原数组，然后遍历该 set，当当前值减去一在 set 中存在则跳过，否则向右端扩展，若在 unorder_set 中能找到则移除且计数加一，不能找到则跳出。然后判断最大长度。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 129 . 求根节点到叶节点数字之和

&emsp; &emsp; BFS 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 130 . 被围绕的区域

&emsp; &emsp; 根据分析可知，只要不与边界的 O 相连接的 O 都会被置为 X，因此对这些 O 进行标记即可。<br/>
&emsp; &emsp; 时间复杂度 O(n * m)，空间复杂度为 O(max(n, m))。

## 131 . 分割回文串

&emsp; &emsp; 方法 1：DFS 加上记忆化搜索即可。判断每个长度的是否为回文串，同时使用临时变量对已经遍历过的回文串进行记录，然后对剩下的字符串进行递归。<br/>
&emsp; &emsp; 时间复杂度 O(n * 2 ^ n)，空间复杂度为 O(n ^ 2)。<br/>
&emsp; &emsp; 方法 2：使用动态规划构建判断是否为回文串的 dp 数组以节省判断回文串的时间。<br/>
&emsp; &emsp; 构建一个长和宽都为 sLength 且全为 true 的 dp 数组，dp 条件为 dp[i + 1][j - 1] && s[i] == s[j]。dp 数组的含义为 s 从 i 到 j 之间是否为回文串。<br/>
&emsp; &emsp; 时间复杂度 O(n * 2 ^ n)，空间复杂度为 O(n ^ 2)。<br/>

## 132 . 分割回文串

&emsp; &emsp; 使用上述的动态规划条件建立回文字符串的查询数组 palidromeRecord，然后建立一个 dp 数组 minCut 用以获取最短长度。从 0 遍历到 sLength，当 palidromeRecord[0][i] 为 true 时，minCut[i]，表示从 0 到 i 不需要分割即为回文串。当 palidromeRecord[0][i] 为 false 时，则需要从 0 遍历到 i，当 palidromeRecord[j + 1][i] 为 true 时，minCut[i] = min(minCut[i], minCut[j] + 1)。<br/>
&emsp; &emsp; 时间复杂度 O(n * 2 ^ n)，空间复杂度为 O(n ^ 2)。

## 133 . 克隆图

&emsp; &emsp; BFS，然后使用 unordered_map<int, Node*> 避免重复添加节点即可。使用队列存储需要添加 neighbors 的 Node，当 map 中不存在时加入队列即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 134 . 加油站

&emsp; &emsp; 根据分析可知，当从起点 i 跑了 count 个加油站后，如果无法到达终点站，则中间的都不可能跑到终点站，因为中间的起点油量只会比开始的起点更少，因此这些地方都不需要遍历。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 135 . 分发糖果

&emsp; &emsp; 使用与 42 题类似的爬坡算法，分别从左到右以及从右到左遍历数组，建立两个数组记录糖果数，当上升时糖果数 +1，否则糖果数置为 1。然后这两个数组的最大糖果数即为当前孩子的糖果数。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 136 . 只出现一次的数字

&emsp; &emsp; 根据计算的性质，同一个数字被异或两次会变成 0，逐步异或即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 137 . 只出现一次的数字 II

&emsp; &emsp; 将每一位进行相加，然后对 3 取余，然后再加上该位即可。<br/>
&emsp; &emsp; 时间复杂度 O(Kn)，空间复杂度为 O(1)。K = 32。

## 138 . 复制带随机指针的链表

&emsp; &emsp; 方法 1：利用哈希表将原节点和新节点对应起来即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。<br/>
&emsp; &emsp; 方法 2：原地处理，通过将新节点插入到原节点之后，然后新节点的下一个节点即原来的下一个节点。以实现空间复杂度为 O(1) 的算法。<br/>
&emsp; &emsp; 需要遍历三次链表，时间复杂度 O(n)，空间复杂度为 O(1)。

## 139 . 单词拆分

&emsp; &emsp; 建立长度为 sLength + 1 的 dp 数组，dp[0] = true，从 1 开始遍历，dp[i] 表示从 0 到 i 是否可以用 wordDict 中的单词拼接。最后返回 dp[sLength] 即为结果。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 140 . 单词拆分 II

&emsp; &emsp; DFS 加上记忆化搜索。使用字符串记录当前的字符串，使用 vector<vector<string>> 记录已经调用过 subStr 获取到的字符串，使用 vector<vector<int>> 记录从 startIndex 开始到指定长度是否被判断过存在。-1 代表不存在，0 代表为判断，1 代表判断存在。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ n)，空间复杂度为 O(n ^ 2)。

## 141 . 环形链表

&emsp; &emsp; 双指针，一个指针每次进二，一个指针每次进一，当两个指针相同时即存在环。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 142 . 环形链表 II

&emsp; &emsp; 根据数学分析可知，当快慢指针相遇时，从头指针出发，慢指针继续往下一个遍历，当两者相遇时就是环的入口。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 143 . 重排链表

&emsp; &emsp; 分析题目，即在中间将链表分为两块，然后将后半链表反转，再把两个链表合并。根据此思路做题。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 144 . 二叉树的前序遍历

&emsp; &emsp; 使用栈，出栈时直接将当前值加入结果，然后每次先放右节点，再放左节点即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 145 . 二叉树的后序遍历

&emsp; &emsp; 需要使用一个临时节点对栈顶进行模拟，当当前节点的右节点为空或者当前节点右节点是上次访问的节点时，将当前节点加入结果列表。否则将当前节点重新入栈然后将当前节点指向其右节点。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 146 . LRU 缓存

&emsp; &emsp; 自定义一个双向链表 LinkedListNode 以实现线形的插入和删除，使用 unorder_set<int, LinkListNode*> 以供查询对应的节点。<br/>
&emsp; &emsp; 当插入值时，判断是否存在该键值，存在则将对应节点的值更新并将其插入头部。不存在则需根据是否超出缓存长度判断是否需要移除尾部元素。<br/>
&emsp; &emsp; 查询值时，将查询的节点更新到头部即可。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度为 O(n)。

## 147 . 对链表进行插入排序

&emsp; &emsp; 梳理链表从后面插入到前面的逻辑，需要使用四个指针，分别为待移动节点的前一个节点的指针，待移动节点的指针，待移动节点的后一个节点的指针，同时需要指针指向从链表开头遍历到结尾找到第一个插入点指针。<br/>
&emsp; &emsp; 插入后调整原位置的指针，以及插入后位置的指针，同时将当前节点指针指向下一个节点的指针。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 2)，空间复杂度为 O(1)。

## 148 . 排序链表

&emsp; &emsp; 方法 1：自顶向下归并排序。每次找中间节点，然后通过该中间节点将前面的节点的 next 置为空，再将左右两个节点合并。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn)，空间复杂度为 O(nlogn)。<br/>
&emsp; &emsp; 方法 1：自底向上归并排序。遍历 logn 次，每次找到 2 ^ k 次方区间，然后合并这两个区间。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn)，空间复杂度为 O(1)。<br/>

## 149 . 直线上最多的点数

&emsp; &emsp; 方法 1：暴力法，每两个点 point[i]、point[j] 遍历，然后对剩下的点进行遍历，由于前面的遍历已经判断过后续的结果，因此只需从 point[j + 1] 开始遍历判断斜率是否相等即可。斜率判断则需要计算 x 和 y 差值的最大公约数再把 x 和 y 的差值除以最大公约数。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 3)，空间复杂度为 O(1)。<br/>
&emsp; &emsp; 方法 2：使用哈希表记录每个点与当前点的连线的斜率，然后遍历哈希表获得各个斜率的点的个数，从而获得最大的点数。<br/>
&emsp; &emsp; 时间复杂度 O(n ^ 2)，空间复杂度为 O(n)。

## 150 . 逆波兰表达式求值

&emsp; &emsp; 送分题，写 Atoi 函数，当遍历到的字符串不是运算符时，将数字进栈。如果是运算符，则连续出两次栈，先出的为右，后出的为左，然后对左右进行相应的计算，再把计算的结果入栈即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(n)。

## 151 . 翻转字符串里的单词

&emsp; &emsp; 使用左右两个指针，当遇到空格时，判断左右指针是否一致，不一致则存在单词需要赋值。然后将左右两个指针都指向当前位置。如果遇到字母，则左指针向左移一位即可。遍历完字符串后需要判断当前左右指针是否一致以避免最后为单词的情况。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 152 . 乘积最大子数组

&emsp; &emsp; 使用左右两个指针，当遇到空格时，判断左右指针是否一致，不一致则存在单词需要赋值。然后将左右两个指针都指向当前位置。如果遇到字母，则左指针向左移一位即可。遍历完字符串后需要判断当前左右指针是否一致以避免最后为单词的情况。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度为 O(1)。

## 153 . 寻找旋转排序数组中的最小值

&emsp; &emsp; 根据分析可知，使用二分法，当中间元素小于右边元素时，中间元素可能为最小值，为避免排除该中间元素， right = middle。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度为 O(1)。

## 154 . 寻找旋转排序数组中的最小值 II

&emsp; &emsp; 153 题变种，送分题。<br/>
&emsp; &emsp; 最差时可能全部元素为相同元素，时间复杂度 O(n)，空间复杂度为 O(1)。

## 155 . 最小栈

&emsp; &emsp; 使用一个栈记录与最小值的差值，然后实时更新最小值。当栈为空时，最小值即为当前值，栈顶元素为 0。当栈顶元素小于 0 时，返回当前最小值，若出栈需要更新最小值。<br/>
&emsp; &emsp; 所有操作时间复杂度 O(1)，空间复杂度为 O(n)。

## 160 . 相交链表

&emsp; &emsp; 声明两个指针 a、b 遍历两个链表，当链表 a 遍历完时将其指向 listB，b 遍历完时将其指向 listA，若两个链表存在交点，则最后会同时指向同一节点。不相交则为指向 nullptr。<br/>
&emsp; &emsp; 时间复杂度 O(m + n)，空间复杂度为 O(1)。

## 162 . 寻找峰值

&emsp; &emsp; 根据分析可知，当元素值不重复时，通过二分总能找到一个中间点使得该点为峰值。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度为 O(1)。

## 164 . 最大间距

&emsp; &emsp; 方法 1：使用基数排序对数组进行排序，然后再寻找最大差值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：使用桶的思想。根据分析可知，把所有数组分为 numsSize 个桶，最大差值肯定出现在两个桶之间的差值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 165 . 比较版本号

&emsp; &emsp; 方法 1：先分隔字符串，然后判断各个字符串的数字是否一样。<br/>
&emsp; &emsp; 时间复杂度 O(n + m)，空间复杂度 O(n + m)。<br/>
&emsp; &emsp; 方法 2：双指针法。<br/>
&emsp; &emsp; 时间复杂度 O(n + m)，空间复杂度 O(1)。

## 166 . 分数到小数

&emsp; &emsp; 将分子分母赋予到一个 64 位的值，然后判断是否能被整除，不可以则取余后用余数来算出小数位。每次计算前当前数 *10 然后与分母相除为小数位，取余得到下一次的循环值。<br/>
&emsp; &emsp; 使用一个 unorder_map 来存储当前取余数是否出现过，若出现则表示存在循环小数。<br/>
&emsp; &emsp; 时间复杂度 O(L)，空间复杂度 O(L)，L为结果字符串的长度。

## 167 . 两数之和 II - 输入有序数组

&emsp; &emsp; 送分题，双指针。<br>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 168 . Excel表列名称

&emsp; &emsp; 对当前数字先减一然后对 26 取余得到最后一位的结果，然后 /= 26 得到下一轮循环的数字。<br>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 169 . 多数元素

&emsp; &emsp; 使用一个变量记录当前的众数，若当前数与众数相等则计数 +1，不等则计数 -1，若计数小于 0，则当前数为当前众数。<br>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 171 . Excel 表列序号

&emsp; &emsp; 送分题。<br>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 172 . 阶乘后的零

&emsp; &emsp; 根据分析可知，计算乘积中存在的5的幂数即可。<br>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 173 . 二叉搜索树迭代器

&emsp; &emsp; 使用栈存放左节点即可，然后出栈时将其右节点放入栈，然后再放入其左节点。<br>
&emsp; &emsp; 根据分析可知，均摊时间复杂度为 (O(logn) + 2 * O(logn - 1) + 4 * O(logn - 2) + ... + n * O(log1)) / n = O(1)。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(h)。

## 174 . 地下城游戏

&emsp; &emsp; dp。由于从前到后进行 dp 将在每次 dp 时存在两条可能的最小路径，无法给出有效的 dp，因此从后往前进行 dp。<br>
&emsp; &emsp; 从后往前dp条件为取右边以及下边的最小值，然后使用该最小值减去当前格子的值，与1取最大值。<br/>
&emsp; &emsp; 意为最小需要的生命值，以及是否需要在当前格子超过 1 的生命值。<br/>
&emsp; &emsp; 时间复杂度 O(M * N)，空间复杂度 O(M)。

## 175 . 组合两个表

&emsp; &emsp; SQL送分题。

## 176 . 第二高的薪水

&emsp; &emsp; 使用 DISTINCT 语句对重复薪水进行筛选，然后使用 ISNULL 函数，当没取到对应的第二大的值时返回 NULL。

## 177 . 第N高的薪水

&emsp; &emsp; 先声明一个变量用于存储 N - 1 的值的变量，然后将 176 的 limit 的偏移值取为 N - 1 即可。

## 178 . 分数排名

&emsp; &emsp; 使用 JOIN 以及子查询，子查询为 SELECT Score GROUP BY Score ORDER BY Score DESC 以及使用一个临时变量循环以存储当前的 Rank，然后将原表与该子查询表进行连接即可。

## 179 . 最大数

&emsp; &emsp; 使用排序，排序条件为两个数字先后拼接时的数字大小。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn * logm)，空间复杂度为递归空间 O(logn)。m 为数字长度。

## 180 . 连续出现的数字

&emsp; &emsp; 使用子查询，以及使用 row_number() 分别记录 ID 出现的行，以及对 Num 进行分组然后根据 Id 排序后的 row_number()，两个 row_number 相减后，根据相减过后的列进行分组。然后选出计数大于等于 3 个的数字。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn * logm)，空间复杂度为递归空间 O(logn)。m 为数字长度。

## 181 . 超过经理收入的员工

&emsp; &emsp; 使用 JOIN 即可。

## 182 . 查找重复的电子邮箱

&emsp; &emsp; 使用 GROUP + HAVING COUNT 即可。

## 183 . 从不订购的客户

&emsp; &emsp; 使用 LEFT JOIN 加上 WHERE CustomerId IS NULL 即可。

## 184. 部门工资最高的员工

&emsp; &emsp; 使用 GROUP BY 选出各部门最高的工资，然后将该临时表与 Employee 表和 Department 表进行 JOIN 即可。

## 185 . 部门工资前三高的所有员工

&emsp; &emsp; 使用窗口函数 DENSE_RANK 选出各个部门前三工资的员工，然后与 Department 进行 JOIN 操作即可。

## 187 . 重复的DNA序列

&emsp; &emsp; 方法 1：每 10 个字符记录字符串是否存在过。<br/>
&emsp; &emsp; 时间复杂度 O(kn)，空间复杂度 O(n)。k = 10。<br/>
&emsp; &emsp; 方法 2：将 ACGT 分别映射到 0、1、2、3，然后记录每个字符串的值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 188 . 买卖股票的最佳时机 IV

&emsp; &emsp; 123 题变种，与 123 题一样的 dp 条件即可。<br/>
&emsp; &emsp; 时间复杂度 O(kn)，空间复杂度 O(k)。

## 189 . 轮转数组

&emsp; &emsp; 方法 1：使用数组存储后 k 位数字，然后删除 nums 的后 k 位数字，再把这些数字插入到开头。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(k)。<br/>
&emsp; &emsp; 方法 2：使用数组存储前 size - k 位数字，然后删除 nums 的前 size - k 位数字，再把这些数字插入到结尾。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n - k)。<br/>
&emsp; &emsp; 方法 3：先将数组进行翻转，然后对前 k 位数字进行反转，再对后 n - k 位数字进行反转。<br/>
&emsp; &emsp; 时间复杂度 O(2n)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 4：进行数学分析可知，每个 (i + k) % numsSize 下标的数字将被赋值为 i，该步骤需要执行 gcd(k, n) 次才能确保每个数字被赋值到。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 190 . 颠倒二进制位

&emsp; &emsp; 方法 1：遍历 32 次，依次颠倒 32 位二进制数字<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：使用位运算，自底向上翻转。每1位、2位、4位、8位最后对16位进行交换。<br/>
&emsp; &emsp; 时间复杂度 O(loglogn)，空间复杂度 O(1)。

## 191 . 位1的个数

&emsp; &emsp; 方法 1：不断与 1 进行位与计算。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：将位与条件更改为 n = n & (n - 1)，从而确保每次除去数字最右边的 1 以减少循环次数。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 3：使用与 190 类似的位运算，使左边的 1 都聚集到右边，从而计算出 1 的总个数。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 4：参照 JDK 的获取 1 的个数进行位运算。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 196 . 删除重复的电子邮箱

&emsp; &emsp; 使用窗口函数 ROW_NUMBER() 对邮箱进行分类，然后除去所有 rowNumber > 1 的邮箱。

## 197 . 上升的温度

&emsp; &emsp; 使用窗口函数 Lag 选取前一天的温度，同时使用 DATEDIFF 计算出相差为 1 的天数即可。

## 198 . 打家劫舍

&emsp; &emsp; 根据分析可知，今天的最大收益与为前天的最大收益加上今天的收益、以及昨天收益的最大值。根据此条件进行 dp 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 199 . 二叉树的右视图

&emsp; &emsp; 根据分析可知，需要进行广度优先遍历，使用队列存储左右结点。当队列长度为 1 时，将当前值加入结果列表即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 200 . 岛屿问题

&emsp; &emsp; 130 变种，广度优先搜索即可。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，空间复杂度 O(m * n)。

## 201 . 数字范围按位与

&emsp; &emsp; 根据分析可知，只需要找 left 和 right 的公共二进制前缀即可。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 202 . 快乐数

&emsp; &emsp; 由于到最后总会成为循环或者到 1，而 1 的平方也是循环，所以可使用快慢指针法。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 203 . 移除链表元素

&emsp; &emsp; 送分题。

## 204 . 计数质数

&emsp; &emsp; 方法 1：使用数组记录下各个数字是否为质数，可以先为 2 的倍数进行判断，然后判断当前数字时，将其递增式改为 2 * i 以减少埃氏筛时一半的遍历次数。<br/>
&emsp; &emsp; 时间复杂度 O(nloglogn), 空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：线性筛：通过一个数组记录已记录的质数，另一个数组记录当前数字是否为质数，然后只在当前数字与质数相乘得到其余的合数，同时当当前数字能够整除已记录的质数时，取消后续遍历从而避免了重复计算。<br/>
&emsp; &emsp; 时间复杂度 O(n), 空间复杂度 O(n)。<br/>

## 205 . 同构字符串

&emsp; &emsp; 通过两个 map 来判断当前字母是否已加入映射表，以及映射后的字母是否已经存在与映射表中。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 206 . 反转链表

&emsp; &emsp; 方法 1：迭代法：使用一个指针 preListNode，指向翻转前的当前结点 head，另一个指针指向翻转前的下一个结点 nextListNode = head->next，然后每次遍历以当前节点是否为空作为判断条件，随后将 head->next 指向 preListNode，preListNode 指向 head，head 指向 nextListNode 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：递归法：使用函数递归，以当前节点或下一个节点为空作为返回条件，返回当前节点，否则进行下一次递归。递归核心函数为将当前 head->next->next 指向 head，同时 head->next = nullptr。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 207 . 课程表

&emsp; &emsp; 方法 1：使用 map 存放当前课程的前置课程进行广度优先遍历，然后使用一个 bool 数组表示课程是否需要作为前置课程，每轮遍历若当前课程的前置课程需要作为前置课程，则返回 false。同时可以将 map 对应的课程移除以减少遍历次数，同时将 map 是否为空作为遍历退出的条件。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：使用拓扑排序，进行广度优先遍历。使用数组存放每个课程的前置课程数 preCourseCount，用另一个数组存放某前置课程的所有后置课程 courseAfterThisCourse。然后遍历 preCourseCount 找到所有前置课程数为 0 的课程，然后通过查询其后置课程，将其后置课程的前置课程数减一，以此类推。<br/>
&emsp; &emsp; 根据有向图找环的速度可知，时间复杂度 O(n + m)，空间复杂度 O(n + m)。n 为课程数，m 为先修课程数。<br/>
&emsp; &emsp; 方法 3：使用有向图的方式，将前置课程的后置课程作为边，然后使用一个额外的变量标记当前点是否被遍历过，以及是否需要再次被遍历，需要三个状态因此采用 int 数组。如果需要被遍历过，则返回 false 即可。。<br/>
&emsp; &emsp; 时间复杂度 O(n + m)，空间复杂度 O(n + m)。n 为课程数，m 为先修课程数。

## 208 . 实现 Trie (前缀树)

&emsp; &emsp; 由于需要知道下一层的节点信息以提供查询，所以需要使用指针 vector 或者指针 map，但使用 map 开销比 vector 大同时效率低，因此使用 vector 记录下一层的指针。<br/>
&emsp; &emsp; 同时需要知道当前是否为单词的结束，需要使用一个 bool 变量记录。<br/>
&emsp; &emsp; 时间复杂度初始化为 O(1)，其他操作为 O(S)，空间复杂度 O(T * 26)。26 代表着 26 个字母，T 为插入的所有字符串的总长度。

## 209 . 长度最小的子数组

&emsp; &emsp; 方法 1：滑动窗口。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：前缀和 + 二分查找<br/>
&emsp; &emsp; 使用数组 sums 记录下 nums 的从 0 到 i 的总和，然后 int temp = result + sums[i - 1]，随后在 i 到 numsSize 中二分查找 temp 是否存在于 nums。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn)，空间复杂度 O(n)。

## 210 . 课程表 II

&emsp; &emsp; 207 题变种，稍作修改即可。<br/>
&emsp; &emsp; 时间复杂度 O(n + m)，空间复杂度 O(n + m)。n 为课程数，m 为先修课程数。

## 211 . 添加与搜索单词 - 数据结构设计

&emsp; &emsp; 208 题变种，稍作修改即可。<br/>
&emsp; &emsp; 时间复杂度初始化为 O(1)，插入操作为 O(S)，搜索操作为 O(26 ^ S)，空间复杂度 O(T * 26)。26 代表着 26 个字母，T 为插入的所有字符串的总长度。

## 212 . 单词搜索 II

&emsp; &emsp; 79 题变种，由于为单词列表，同时存在有速度要求，因此可使用单词树的做法尽早进行减枝。<br/>
&emsp; &emsp; 而单词树需要在 208 题的基础上进行更改，直接返回后续的字典树节点以减少重复的判断导致超时。<br/>
&emsp; &emsp; 同时可增加删除单词树的方法对已添加字符串的重复判断。<br/>
&emsp; &emsp; 时间复杂度 O(m * n * 3 ^ L)，空间复杂度为 O(K * L)，m、n 为行和列数，K 和 L 为字符串个数以及最长字符串长度。

## 213 . 打家劫舍 II

&emsp; &emsp; 198 题变种，由于需要考虑是否偷第一家，所以可通过两次遍历的方式，分别看考虑第一家不考虑最后一家，以及不考虑第一家考虑最后一家的情况进行 dp。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 214 . 最短回文串

&emsp; &emsp; 找到最长的回文串前缀，然后将后续的字符串倒序复制到开头即可。<br/>
&emsp; &emsp; 由于存在效率上的要求，需要使用马拉车算法进行回文串的查找。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 215 . 数组中的第K个最大元素

&emsp; &emsp; 只对包含 k 的数组快排即可。同时需要使用随机的下标作为分割标志以避免连续重复数字时多次排序导致的时间复杂度变得复杂。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(logn)。

## 216 . 组合总和 III

&emsp; &emsp; 找出所有的组合，然后对组合的总和进行计算，看是否等于总和，否则跳出递归。<br/>
&emsp; &emsp; 时间复杂度 O(C(m, k) * k)，空间复杂度 O(k)。m 为集合大小，固定为 9。

## 217 . 存在重复元素

&emsp; &emsp; 送分题。set 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 218 . 天际线问题

&emsp; &emsp; 扫描线问题。<br/>
&emsp; &emsp; 1. 为先使用数组 boundaries 记录下所有的边。<br/>
&emsp; &emsp; 2. 遍历 boundaries 以及遍历原 buildings 的三元组，将所有的包含该左边的 building 的右边以及高度放入最大堆 buildingQueue 中。<br/>
&emsp; &emsp; 3. 然后查看 buildingQueue 是否堆顶的坐标小于 boundary，是则弹出，否则则为该 boundary 所能获取的最大高度，若栈为空则高度为 0。然后若上次获取的高度与这次获取的高度相同，则不用作为结果。<br/>
&emsp; &emsp; 时间复杂度为最大堆操作的复杂度 O(nlogn)，空间复杂度 O(n)。

## 219 . 存在重复元素 II

&emsp; &emsp; 使用滑动窗口的思想，每次将窗口最前的数字移除以节省空间。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(k)。

## 220 . 存在重复元素 III

&emsp; &emsp; 方法 1：既有查询也有增加节点以及删除节点的操作，使用 map，map 底层为红黑树，能在 O(logn) 时间内完成查询、插入、删除等操作。通过 lower_bound 找到第一个大于等于 nums[i] - t 的数字，然后将该数字与 nums[i] 的差值与 t 进行对比即可获得结果。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn)，空间复杂度 O(k)。<br/>
&emsp; &emsp; 方法 2：利用桶的思想，将全部数字分为 t + 1 个桶放入 unordered_map 中以避免不必要的内存浪费。然后查询当前数字的 bucketId + 1 以及 bucketId - 1 的桶是否存在于 map 中，若存在则判断该桶放入的值是否与当前值的差值为目标值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(k)。

## 221 . 最大正方形

&emsp; &emsp; 使用动态规划，dp 条件为 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，空间复杂度 O(m * n)。<br/>
&emsp; &emsp; 使用滚动数组，另外单独使用一个变量保存当前的左上角的值，同时当遍历下一行时，当前左上角的值蓄清 0。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，空间复杂度 O(min(m, n))。

## 222 . 完全二叉树的节点个数

&emsp; &emsp; 方法 1：DFS，左右子树节点数和再 + 1。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(logn)。<br/>
&emsp; &emsp; 方法 2：官方解：将树的结点从 1 - n 命名，则每个树上的节点可使用二进制进行表示，通过二进制从而使用二分查找找到是否特定下标的节点是否存在。<br/>
&emsp; &emsp; 时间复杂度 O(loglogn)，空间复杂度 O(1)。

## 223 . 矩形面积

&emsp; &emsp; 根据数学分析，若存在重叠区域，重叠区域的投影长度为 {max(ax1, bx1), min(ax2, bx2)},{max{ay1, by1}, min(ay2, by2)}，若两者任一者为负数，则不存在重叠区域。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 224 . 基本计算器

&emsp; &emsp; 方法 1：使用两个栈分别记录下操作符以及数字，由于只存在括号以及 + - 号，所以只需要对括号进行特殊处理即可。同时若出现连续的符号，则将 0 加入数字栈中以减少特殊处理。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：由于只存在括号以及正负号，因此可直接作为从左到右的运算。使用一个栈分别记录下当前数字的符号，使用 1 作为栈中的初始值，当出现左括号时将当前的符号入栈，右括号将当前的符号出栈，出现符号则反置符号，出现数字则通过符号进行计算。<br/>
&emsp; &emsp; 对括号的特殊处理相当于把括号去掉。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 225 . 用队列实现栈

&emsp; &emsp; 方法 1：使用两个队列 _toolQueue、_queueIndeed。当 push 的时候，先往 _toolQueue 中放入 x，然后把 _queueIndeed 的元素依次放入 _toolQueue 中，然后交换 _toolQueue 和 _queueIndeed。top、pop、empty 操作直接使用 _queueIndeed 进行操作即可。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：使用一个队列，push 操作时，记录下当前队列的总长度 n，然后放入 x，依次放入 n 次元素以及弹出 n 次队列即可。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(n)。

## 226 . 翻转二叉树

&emsp; &emsp; 送分题。Dfs 即可。每次交换对当前节点的左右子树进行递归交换，然后交换左右子树即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(logn)。

## 227 . 基本计算器 II

&emsp; &emsp; 通过 224 方法 1 的做法可以改出更为通用的版本。在该基础上添加了映射运算符优先级的 map 以令乘除或者其他符号更为优先计算。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。

## 228 . 合并区间

&emsp; &emsp; 使用双指针法，定义两个下标 left 和 right，将 nums[left] 放入 result 中，然后令 right = left，直到 nums[right + 1] 不等于 nums[right] + 1，然后判断 left 与 right 是否相等，若不相等则合并区间。最后将 left 置为 right + 1 即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 229 . 求众数 II

&emsp; &emsp; 使用摩尔投票法，由于求得是超过 n / 3 的数字，因此至多为 2 个数字。声明两个变量 num1，num2 记录当前数字是否为需要投票的数字，然后声明两个变量 vote1，vote2 得到该数字的票数。遍历数组，若当前数字等于 num1，则 vote1 + 1，num2 同理。若都不相同，当 vote1 或 vote2 等于 0 时，将当前数字赋值给 num1 或 num2。若都不等于 0，则 vote1 - 1，且 vote2 - 1。<br/>
&emsp; &emsp; 进行完投票后，可以得到两个候选数字，需要遍历原数字查看与之相等的数字个数。判断是否超过 n / 3.<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 230 . 二叉搜索树中第K小的元素

&emsp; &emsp; 方法 1：直接使用中序遍历即可。<br/>
&emsp; &emsp; 由于树可能不是 AVL，时间复杂度 O(H + k)，空间复杂度 O(H)。<br/>
&emsp; &emsp; 方法 2：使用 map 记录下节点的各个树的子结点个数，当进行删除或增加操作时更新该 map。<br/>
&emsp; &emsp; 初始化 map 的时间复杂度 O(n)，更新 map 的时间复杂度为 O(H)，空间复杂度 O(n)。查询操作为 O(1)。<br/>
&emsp; &emsp; 方法 3：将不平衡树改为 AVL，保证各个操作事件稳定在 O(logn)。

## 231 . 2 的幂

&emsp; &emsp; 方法 1：分析可知，若 n 为 2 的幂，则 n 的二进制中只会包含一个 1，使用 n & (n - 1) 去除 n 最右边的 1 与 0 进行对比即可，同时需要确保 n 大于 0。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：使用 2 ^ 30 对 n 取余，看是否为 0。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 232 . 用栈实现队列

&emsp; &emsp; 方法 1：使用两个栈 _stackIndeed、_stackTool。当 push 时，将 _stackIndeed 的所有元素放入 _stackTool 中，然后将 x 放入 _stackIndeed 中，再将 _stackTool 的元素放入 _stackIndeed 中。<br/>
&emsp; &emsp; push 操作时间复杂度 O(n)，其他操作时间复杂度 O(1)。空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：push 时，直接 push 到 _stackTool 中，当 pop 以及 peek 时，若 _stackIndeed 为空，将 _stackTool 所有元素放入 _stackIndeed 中然后对 _stackIndeed 进行操作。均摊时间复杂度为 O(1)。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 233 . 数字 1 的个数

&emsp; &emsp; 根据分析可知，小于 n 的数字的 1 的个数为每一位为 1 的总和。以 210012 为例：<br/>
&emsp; &emsp; 个位数为 1 的数字为 21001(1)-00000(1)，共为 21001 - 0 + 1 = (21001 + 1) * 1 = 21002 种可能性。<br/>
&emsp; &emsp; 十位数为 1 的数字为 2100(1)2-0000(1)0 共为 2100 * 10 + 2 - 0 + 1 = 21003 种可能性。<br/>
&emsp; &emsp; 百位数为 1 的数字为 209(1)99-000(1)00 共为 20999 - 0 + 1 = 210 * 100 = 21000 种可能性。<br/>
&emsp; &emsp; 千位数为 1 的数字为 20(1)999-00(1)000 共为 20999 - 0 + 1 = 21 * 1000 = 21000 种可能性。<br/>
&emsp; &emsp; 万位数为 1 的数字为 2(1)0012-0(1)0000 共为 2 * 10000 + 12 - 0 + 1 = 20013 种可能性。<br/>
&emsp; &emsp; 十万位为 1 的数字为 (1)99999-(1)00000 共为 99999 - 0 + 1 = (0 + 1) * 100000 = 100000 种可能性。<br/>
&emsp; &emsp; 然后根据分析可知，当该位原本为 0 时，该位为 1 时，可能性为左边的数字乘以 10 ^ 右边的数字位数。<br/>
&emsp; &emsp; 当该位原本为 1 时，该位为 1 时，可能性为左边的数字乘以 10 ^ 右边的数字位数再加上右边的数字。<br/>
&emsp; &emsp; 当该位原本大于 1 时，该位为 1 时，可能性为左边的数字乘以 10 ^ 右边的数字位数。<br/>
&emsp; &emsp; 时间复杂度 O(logn)，空间复杂度 O(1)。

## 234. 回文链表

&emsp; &emsp; 方法 1：将链表放入数组中，然后双指针法遍历数组即可。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。<br/>
&emsp; &emsp; 方法 2：将后半链表反转，然后遍历前半以及后半链表，遍历完再反转恢复。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 235 . 二叉搜索树的最近公共祖先

&emsp; &emsp; 由于题目为二叉搜索树，根据二叉搜索树的性质，若 p<= root 且 q >= root 则 root 为目标节点。若 p < root，则 root = root->left，否则 root = root->right 进行循环即可。<br/>
&emsp; &emsp; 时间复杂度 O(H)，空间复杂度 O(1)。

## 236 . 二叉树的最近公共祖先

&emsp; &emsp; DFS，先判断当前节点是否为空，若为空返回空。然后判断当前节点是否为 p 或 q 的值，若为真，则返回当前节点。否则判断当前节点的左右节点是否为 p 或 q，若同时找到 p 或 q，则当前节点即为结果。否则找到那个为 p 或为 q 即为哪个结果。<br/>
&emsp; &emsp; 时间复杂度 O(N)，空间复杂度 O(H)。

## 237 . 删除链表中的节点

&emsp; &emsp; 由于题目保证了不为末尾结点，直接把当前节点的值赋值为下一个节点的值，删除下一个节点并将下下个节点赋值为当前节点的下一个节点。<br/>
&emsp; &emsp; 时间复杂度 O(1)，空间复杂度 O(1)。

## 238 . 除自身以外数组的乘积

&emsp; &emsp; 先遍历数组，统计 0 的个数，若 0 的个数大于等于 2，则返回全为 0 的数组即可。若为 1，则找到 0 所在的位置，然后其他位数为 0，计算该位的值。若为 0，则计算出总的乘积，然后每一位的结果为总乘积除以当前数字。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(1)。

## 239 . 滑动窗口最大值

&emsp; &emsp; 方法 1：使用优先队列，队列的泛型为 pair<int, int>，意为当前的值以及下标。当下标小于新窗口的左侧时才弹出。<br/>
&emsp; &emsp; 时间复杂度 O(nlogn)，由于可能是单调递增序列，空间复杂度最坏为 O(n)。<br/>
&emsp; &emsp; 方法 2：使用单调队列，队列中放入的为下标值。思想为当新的窗口值大于先前的窗口值时，由于需要考虑先前的窗口值时必然会考虑到新的更大的窗口值，因此可以将先前的窗口值不做考虑。即弹出。<br/>
&emsp; &emsp; 建立窗口，当后续的值比前面的值大时，弹出前面的值，放入最后的下标。然后结果放入双端队列的队首的下标所对应的值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，由于总会弹出剩下k个元素，空间复杂度为 O(k)。<br/>
&emsp; &emsp; 方法 3：使用前缀与后缀的思想<br/>
&emsp; &emsp; 第 i 位的最大值为 suffixMax[i] 以及 prefixMax[i + k - 1] 中的最大值。同时当 i % k == 0 时，需要重置前缀和为当前下标的数字。当 i == n - 1 或 (i + 1) % k == 0 时需要重置后置和为当前下标的数字，确保分组的稳定性。然后遍历两个数组求出当前最大值。<br/>
&emsp; &emsp; 时间复杂度 O(n)，保存所有前缀最大值和后缀最大值的空间复杂度为 O(n)。

## 240 . 搜索二维矩阵 II

&emsp; &emsp; 方法 1：遍历所有元素。<br/>
&emsp; &emsp; 时间复杂度 O(m * n)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 2：对各行进行二分查找。<br/>
&emsp; &emsp; 时间复杂度 O(mlogn)，空间复杂度 O(1)。<br/>
&emsp; &emsp; 方法 3：进行 Z 字查找，初始值为右上角的值，若目标值大于当前值，则向下寻找，若目标值小于当前值，则向左寻找。<br/>
&emsp; &emsp; 时间复杂度 O(m + n)，空间复杂度 O(1)。



## 637 . 二叉树的层平均值

&emsp; &emsp; 广度优先搜索。<br/>
&emsp; &emsp; 时间复杂度 O(n)，空间复杂度 O(n)。
