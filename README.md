# LeetCode
## 001 . 两数之和
方法1：先排序，然后选出和为目标值的数字，再返回原数组查找<br/>
方法2：使用哈希表，然后遍历数组，看是否存在 target - left 的值
## 002 . 两数相加
先创建一个空节点，指向真正的用来指向真正的头结点，并用来保证代码的一致性。<br/>
通过一个临时值记录下一位是否进1，以保证下一位不会被遗漏。
## 003 . 无重复字符的最长子串
通过 int 数组充当 hash 表，以判断前面出现的同样的字符的下标
## 004 . 寻找两个正序数组的中位数
方法1：合并两个数组遍历，找到下标为 (m + n) / 2 和 (m + n) / 2 + 1 的值。时间复杂度 O(m + n)，空间复杂度 O(m + n)<br/>
方法2：动态二分查找，由于两个数组都已排序，所以其中的数都在中位数两侧，因此在两个数组可分别找到一个位置，该位置左边与右边的元素个数相同或相差 1，同时在两个数组该位置左侧的元素都比右边的元素要小，找出该位置即可。时间复杂度 O(log(m + n))，空间复杂度 O(1)。
## 005 . 最长回文子串
方法1：中心扩展法。以中心向两端进行比较。时间复杂度 O(n^2)，空间复杂度 O(1)<br/>
方法2：Manacher。中心扩展的同时，根据现中心给右侧的元素赋予回文长度。当右侧回文长度超过当前回文串的长度时，以该元素为中心进行回文检查。
## 006 . Z 字形变换
找规律
## 007 . 整数反转
注意可能会导致超出有效范围的情况。与 MAX_INT/10 和 MIN_INT/10 作对比。以及当已经转移的位数为 30 且当前值等于  MAX_INT/10 或 MIN_INT/10 时，最后一位与 7 进行对比。
## 008 . ATOI
各种特殊情况。先除去前面的空格，然后判断是否存在符号，然后判断前面是否为 0
## 009 . 回文数
用一个数组存储各个位的数字，然后两边进行对比
## 010 . 正则表达式匹配
动态规划。构建 n*m 的数组，其中 dp[i][j] 表示正则表达式 regular 前 i 个字符能否与前 j 个待匹配字符串 target 匹配，最后查看 dp[n][m] 的结果即可。时间 O(n*m)，空间 O(n*m)。<br/>
dp[0][0] 表示 0 个正则表达式与 0 个目标字符串匹配为 true。<br/>
当 regular[j] 为 * 时，dp[i][j] 为 dp[i][j-2] 与 target[i] == regular[j - 1] 或 regular[j - 1] == '.' 时， regular[i][j] 为 true。<br/>
最后 dp[n][m] 即为结果。
## 011 . 盛最多水的容器
双指针法。在两侧同时往中间靠拢，当前的盛水量等于较低的边乘以宽度，随后较短的一侧往中间靠拢以查找是否有更大的值。
## 012 . 整数转罗马数字
通过键值表反向排序，同时插入特殊的如4、9等键值，然后依次相减直至获得最终结果。O(logn)，n为数字位数。
## 013 . 罗马数字转整数
通过键值表反向排序，同时插入特殊的如4、9等键值，然后依次相减直至获得最终结果。O(logn)，n为数字位数。
## 014 . 最长公共前缀
字符串同一位进行匹配即可。
## 015 . 三数之和
先对原数组进行排序，然后通过双指针法找到结果。通过排除重复元素减少重复计算。时间 O(n^2)，空间 O(logn)。
## 016 . 最接近的三数之和
先对原数组进行排序，然后通过双指针法找到结果。每次用当前三个数的和与目标值的差值的绝对值，与之前获得的差值进行比较，较小则替换。时间 O(n^2)。
## 017 . 电话号码的字母组合
创建字典，然后使用数组存储上一次遍历的值，下一次遍历时遍历该数组然后进行字符串的组合即可。时间 O(3^n),空间 O(3^n)。
## 018 . 四数之和
类似于之前三数之和做法，时间 O(n^3)，空间 O(logn)。
## 019 . 删除链表的倒数第 N 个结点
双指针法，一个指针移动了 N 次后，第二个指针才开始移动。时间 O(n)，空间 O(1)。<br/>
同时，使用一个前置节点，以头结点作为该前置节点的下一个节点，返回结果时直接返回前置节点的子结点以减少特殊条件的判断。
## 020 . 有效的括号
使用栈，当左括号时入栈，右括号时出栈然后判断是否是对应的括号。<br/>
通过一个数组作为 HashMap，通过该数组判断括号是否匹配。
## 021 . 合并两个有序链表
使用一个前置节点，以头结点作为该前置节点的下一个节点，返回结果时直接返回前置节点的子结点以减少特殊条件的判断。
## 022 . 括号生成
迭代，用左括号以及右括号剩余个数作为参数，当两个个数一致时将生成的字符串放入结果中。<br/>
该问题可视为入栈出栈问题，时间复杂度为卡特兰数通项 O(4^n/n^(1/2))，空间复杂度为递归深度 O(n)。
## 023 . 合并K个升序链表
先构造一个小堆顶，堆的长度为非空链表个数 + 1, 加 1 为了添加一个零号节点，用于方便后续调整的判断。将每个链表的首元素放进去，初始化堆之后，每次取堆的下标为 1 的元素。如果该元素存在下一个节点，则将该下标的元素赋值为该下一个节点，同时对堆进行调整。若不存在下一个节点，则堆的长度 -1，同时将最后一个元素赋值给第一个元素，然后进行调整，直到堆的长度为 1，即零号节点则全部元素获取完毕。<br/>
时间复杂度 O(nlog(m))，空间复杂度为 O(m)。n 为所有链表总元素个数，m 为链表数组的链表元素个数。
## 024 . 两两交换链表中的节点
日常用一个空置节点减少判断。然后分别记录下交换后的后一个节点以作为下一次节点交换的前节点。<br/>
时间复杂度 O(n)，空间复杂度 O(1)。
## 025 . K 个一组翻转链表
日常用一个空置节点减少判断。然后可以转过来想，相当于把后面的节点都插入到第一个节点，然后将该节点的首位置进行重置，只需要声明两个指针即可完成工作。<br/>
时间复杂度 O(n)，空间复杂度 O(1)。
## 026 . 删除有序数组中的重复项
设置两个指针 left,right，初始值都为 1，当 nums[right - 1] == nums[right] 时，将 nums[left] 赋值为 nums[right] 同时 left++。<br/>
时间复杂度 O(n)，空间复杂度 O(1)。
## 027 . 移除元素
双指针，然后左指针相等时，将其与右指针的值交换，同时右指针不能为相同的元素值，并且记录相同元素个数，然后返回数组长度减去相同元素个数。<br/>
时间复杂度 O(n)，空间复杂度 O(1)。
## 028 . 实现 strStr
KMP，先构造 KMP 数组，该数组记录了每次重新匹配开始的位置，避免了暴力搜索的多余的匹配。<br/>
时间复杂度 O(n)，空间复杂度 O(m)，n 为源字符串 haystack 的长度，m 为目标字符串 needle 的长度。
## 029 . 两数相除
每次使用移位来进行幂级别的商。由于 LeetCode 上的 C++ 编译器不支持负数的位运算以及对 INT32_MIN 的取负操作，所以使用 unsigned int 并且使用位运算将负数转换为 unsigned 的正数，并在返回时再进行一次位运算返回负数。<br/>
时间复杂度 O(logn)，空间复杂度 O(1)。n 为 dividend/divisor。
## 030 . 串联所有单词的子串
建立哈希表，分别记录每个单词需要出现的次数，每个单词已经出现的下标，每次出现单词的下标与对应的单词。当上一轮循环没有找到到此且这轮循环找到单词时，直接插入哈希表。如果上一轮循环找到，这轮找到，且出现次数未超出限制，则直接插入，否则需要去除该单词第一次出现的下标前的信息。<br/>
循环 K 次滑动窗口，K为单词的长度，由于单词长度一致，所以窗口每次循环移动为 K。一轮窗口循环后下标 +1 再执行循环，直至 K 次循环完成。<br/>
时间复杂度 o(Kn)，n 为字符串 s 的长度。空间复杂度 o(m)，m 为字符串组 words 的字符串个数。
